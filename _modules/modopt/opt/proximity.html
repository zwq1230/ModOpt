

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>modopt.opt.proximity &mdash; modopt 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> modopt
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modopt.html">1. modopt package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../modopt.base.html">1.1.1. modopt.base package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.base.np_adjust.html">1.1.1.1.1. modopt.base.np_adjust module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.base.observable.html">1.1.1.1.2. modopt.base.observable module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.base.transform.html">1.1.1.1.3. modopt.base.transform module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.base.types.html">1.1.1.1.4. modopt.base.types module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.base.wrappers.html">1.1.1.1.5. modopt.base.wrappers module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modopt.interface.html">1.1.2. modopt.interface package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.interface.errors.html">1.1.2.1.1. modopt.interface.errors module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.interface.log.html">1.1.2.1.2. modopt.interface.log module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modopt.math.html">1.1.3. modopt.math package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.math.convolve.html">1.1.3.1.1. modopt.math.convolve module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.math.matrix.html">1.1.3.1.2. modopt.math.matrix module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.math.metrics.html">1.1.3.1.3. modopt.math.metrics module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.math.stats.html">1.1.3.1.4. modopt.math.stats module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modopt.opt.html">1.1.4. modopt.opt package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.opt.algorithms.html">1.1.4.1.1. modopt.opt.algorithms module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.opt.cost.html">1.1.4.1.2. modopt.opt.cost module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.opt.gradient.html">1.1.4.1.3. modopt.opt.gradient module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.opt.linear.html">1.1.4.1.4. modopt.opt.linear module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.opt.proximity.html">1.1.4.1.5. modopt.opt.proximity module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.opt.reweight.html">1.1.4.1.6. modopt.opt.reweight module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modopt.plot.html">1.1.5. modopt.plot package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.plot.cost_plot.html">1.1.5.1.1. modopt.plot.cost_plot module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modopt.signal.html">1.1.6. modopt.signal package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.signal.filter.html">1.1.6.1.1. modopt.signal.filter module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.signal.noise.html">1.1.6.1.2. modopt.signal.noise module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.signal.positivity.html">1.1.6.1.3. modopt.signal.positivity module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.signal.svd.html">1.1.6.1.4. modopt.signal.svd module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.signal.validation.html">1.1.6.1.5. modopt.signal.validation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modopt.signal.wavelet.html">1.1.6.1.6. modopt.signal.wavelet module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modopt.info.html">1.2.1. modopt.info module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">2. modopt examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../plugin_example.html">2.1. Plugin Example</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">modopt</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>modopt.opt.proximity</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for modopt.opt.proximity</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;PROXIMITY OPERATORS</span>

<span class="sd">This module contains classes of proximity operators for optimisation</span>

<span class="sd">:Author: Samuel Farrens &lt;samuel.farrens@cea.fr&gt;</span>

<span class="sd">:References:</span>

<span class="sd">.. bibliography:: refs.bib</span>
<span class="sd">    :filter: docname in docnames</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">sklearn.isotonic</span> <span class="kn">import</span> <span class="n">isotonic_regression</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">import_sklearn</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">import_sklearn</span> <span class="o">=</span> <span class="kc">True</span>

<span class="kn">from</span> <span class="nn">modopt.base.types</span> <span class="kn">import</span> <span class="n">check_callable</span>
<span class="kn">from</span> <span class="nn">modopt.signal.noise</span> <span class="kn">import</span> <span class="n">thresh</span>
<span class="kn">from</span> <span class="nn">modopt.signal.svd</span> <span class="kn">import</span> <span class="n">svd_thresh</span><span class="p">,</span> <span class="n">svd_thresh_coef</span>
<span class="kn">from</span> <span class="nn">modopt.signal.positivity</span> <span class="kn">import</span> <span class="n">positive</span>
<span class="kn">from</span> <span class="nn">modopt.math.matrix</span> <span class="kn">import</span> <span class="n">nuclear_norm</span>
<span class="kn">from</span> <span class="nn">modopt.base.transform</span> <span class="kn">import</span> <span class="n">cube2matrix</span><span class="p">,</span> <span class="n">matrix2cube</span>
<span class="kn">from</span> <span class="nn">modopt.interface.errors</span> <span class="kn">import</span> <span class="n">warn</span>


<div class="viewcode-block" id="ProximityParent"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.ProximityParent">[docs]</a><span class="k">class</span> <span class="nc">ProximityParent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Proximity Operator Parent Class</span>

<span class="sd">    This class sets the structure for defining proximity operator instances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : function</span>
<span class="sd">        Callable function that implements the proximity operation</span>
<span class="sd">    cost : function</span>
<span class="sd">        Callable function that implements the proximity contribution to the</span>
<span class="sd">        cost</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">cost</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Linear operator</span>

<span class="sd">        This method defines the linear operator.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op</span>

    <span class="nd">@op</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_op</span> <span class="o">=</span> <span class="n">check_callable</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cost contribution</span>

<span class="sd">        This method defines the proximity operator&#39;s contribution to the total</span>
<span class="sd">        cost.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost</span>

    <span class="nd">@cost</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cost</span> <span class="o">=</span> <span class="n">check_callable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span></div>


<div class="viewcode-block" id="IdentityProx"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.IdentityProx">[docs]</a><span class="k">class</span> <span class="nc">IdentityProx</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Identity Proxmity Operator</span>

<span class="sd">    This is a dummy class that can be used as a proximity operator.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The identity proximity operator contributes ``0.0`` to the total cost.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="Positivity"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.Positivity">[docs]</a><span class="k">class</span> <span class="nc">Positivity</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Positivity Proximity Operator</span>

<span class="sd">    This class defines the positivity proximity operator.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">positive</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

<div class="viewcode-block" id="Positivity._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.Positivity._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate positivity component of the cost</span>

<span class="sd">        This method returns 0 as the posivituty does not contribute to the</span>
<span class="sd">        cost.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            ``0.0``</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;verbose&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; - Min (X):&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="mf">0.0</span></div></div>


<div class="viewcode-block" id="SparseThreshold"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.SparseThreshold">[docs]</a><span class="k">class</span> <span class="nc">SparseThreshold</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Threshold Proximity Operator</span>

<span class="sd">    This class defines the threshold proximity operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    linear : class</span>
<span class="sd">        Linear operator class</span>
<span class="sd">    weights : numpy.ndarray</span>
<span class="sd">        Input array of weights</span>
<span class="sd">    thresh_type : {&#39;hard&#39;, &#39;soft&#39;}, optional</span>
<span class="sd">        Threshold type (default is &#39;soft&#39;)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">thresh_type</span><span class="o">=</span><span class="s1">&#39;soft&#39;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span> <span class="o">=</span> <span class="n">linear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_thresh_type</span> <span class="o">=</span> <span class="n">thresh_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

<div class="viewcode-block" id="SparseThreshold._op_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.SparseThreshold._op_method">[docs]</a>    <span class="k">def</span> <span class="nf">_op_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator</span>

<span class="sd">        This method returns the input data thresholded by the weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data array</span>
<span class="sd">        extra_factor : float</span>
<span class="sd">            Additional multiplication factor (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Thresholded data</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="n">extra_factor</span>

        <span class="k">return</span> <span class="n">thresh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thresh_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseThreshold._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.SparseThreshold._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate sparsity component of the cost</span>

<span class="sd">        This method returns the l1 norm error of the weighted wavelet</span>
<span class="sd">        coefficients.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Sparsity cost component</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cost_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

        <span class="k">if</span> <span class="s1">&#39;verbose&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; - L1 NORM (X):&#39;</span><span class="p">,</span> <span class="n">cost_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cost_val</span></div></div>


<div class="viewcode-block" id="LowRankMatrix"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.LowRankMatrix">[docs]</a><span class="k">class</span> <span class="nc">LowRankMatrix</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Low-rank Proximity Operator</span>

<span class="sd">    This class defines the low-rank proximity operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    thresh : float</span>
<span class="sd">        Threshold value</span>
<span class="sd">    treshold_type : {&#39;hard&#39;, &#39;soft&#39;}</span>
<span class="sd">        Threshold type (options are &#39;hard&#39; or &#39;soft&#39;, default is &#39;soft&#39;)</span>
<span class="sd">    lowr_type : {&#39;standard&#39;, &#39;ngole&#39;}</span>
<span class="sd">        Low-rank implementation (options are &#39;standard&#39; or &#39;ngole&#39;, default is</span>
<span class="sd">        &#39;standard&#39;)</span>
<span class="sd">    operator : class</span>
<span class="sd">        Operator class (&#39;ngole&#39; only)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from modopt.opt.proximity import LowRankMatrix</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(9).reshape(3, 3).astype(float)</span>
<span class="sd">    &gt;&gt;&gt; inst = LowRankMatrix(10.0, thresh_type=&#39;hard&#39;)</span>
<span class="sd">    &gt;&gt;&gt; inst.op(a)</span>
<span class="sd">    array([[[  2.73843189,   3.14594066,   3.55344943],</span>
<span class="sd">            [  3.9609582 ,   4.36846698,   4.77597575],</span>
<span class="sd">            [  5.18348452,   5.59099329,   5.99850206]],</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">           [[  8.07085295,   9.2718846 ,  10.47291625],</span>
<span class="sd">            [ 11.67394789,  12.87497954,  14.07601119],</span>
<span class="sd">            [ 15.27704284,  16.47807449,  17.67910614]]])</span>
<span class="sd">    &gt;&gt;&gt; inst.cost(a, verbose=True)</span>
<span class="sd">     - NUCLEAR NORM (X): 469.391329425</span>
<span class="sd">    469.39132942464983</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">thresh_type</span><span class="o">=</span><span class="s1">&#39;soft&#39;</span><span class="p">,</span>
                 <span class="n">lowr_type</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">thresh</span> <span class="o">=</span> <span class="n">thresh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresh_type</span> <span class="o">=</span> <span class="n">thresh_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowr_type</span> <span class="o">=</span> <span class="n">lowr_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

<div class="viewcode-block" id="LowRankMatrix._op_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.LowRankMatrix._op_method">[docs]</a>    <span class="k">def</span> <span class="nf">_op_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator</span>

<span class="sd">        This method returns the input data after the singular values have been</span>
<span class="sd">        thresholded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data array</span>
<span class="sd">        extra_factor : float</span>
<span class="sd">            Additional multiplication factor (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            SVD thresholded data</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Update threshold with extra factor.</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh</span> <span class="o">*</span> <span class="n">extra_factor</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowr_type</span> <span class="o">==</span> <span class="s1">&#39;standard&#39;</span><span class="p">:</span>
            <span class="n">data_matrix</span> <span class="o">=</span> <span class="n">svd_thresh</span><span class="p">(</span><span class="n">cube2matrix</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">threshold</span><span class="p">,</span>
                                     <span class="n">thresh_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thresh_type</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowr_type</span> <span class="o">==</span> <span class="s1">&#39;ngole&#39;</span><span class="p">:</span>
            <span class="n">data_matrix</span> <span class="o">=</span> <span class="n">svd_thresh_coef</span><span class="p">(</span><span class="n">cube2matrix</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span>
                                          <span class="n">threshold</span><span class="p">,</span>
                                          <span class="n">thresh_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thresh_type</span><span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="n">matrix2cube</span><span class="p">(</span><span class="n">data_matrix</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># Return updated data.</span>
        <span class="k">return</span> <span class="n">new_data</span></div>

<div class="viewcode-block" id="LowRankMatrix._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.LowRankMatrix._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate low-rank component of the cost</span>

<span class="sd">        This method returns the nuclear norm error of the deconvolved data in</span>
<span class="sd">        matrix form.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Low-rank cost component</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cost_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresh</span> <span class="o">*</span> <span class="n">nuclear_norm</span><span class="p">(</span><span class="n">cube2matrix</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="s1">&#39;verbose&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; - NUCLEAR NORM (X):&#39;</span><span class="p">,</span> <span class="n">cost_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cost_val</span></div></div>


<div class="viewcode-block" id="LinearCompositionProx"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.LinearCompositionProx">[docs]</a><span class="k">class</span> <span class="nc">LinearCompositionProx</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Proximity Operator of a Linear Composition</span>

<span class="sd">    This class defines the proximity operator of a function given by</span>
<span class="sd">    a composition between an initial function whose proximity operator is known</span>
<span class="sd">    and an orthogonal linear function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    linear_op : class instance</span>
<span class="sd">        Linear operator class</span>
<span class="sd">    prox_op : class instance</span>
<span class="sd">        Proximity operator class</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_op</span><span class="p">,</span> <span class="n">prox_op</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear_op</span> <span class="o">=</span> <span class="n">linear_op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prox_op</span> <span class="o">=</span> <span class="n">prox_op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

<div class="viewcode-block" id="LinearCompositionProx._op_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.LinearCompositionProx._op_method">[docs]</a>    <span class="k">def</span> <span class="nf">_op_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Operator</span>

<span class="sd">        This method returns the scaled version of the proximity operator as</span>
<span class="sd">        given by Lemma 2.8 of :cite:`combettes2005`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data array</span>
<span class="sd">        extra_factor : float</span>
<span class="sd">            Additional multiplication factor (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Result of the scaled proximity operator</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear_op</span><span class="o">.</span><span class="n">adj_op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prox_op</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linear_op</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                                     <span class="n">extra_factor</span><span class="o">=</span><span class="n">extra_factor</span><span class="p">))</span></div>

<div class="viewcode-block" id="LinearCompositionProx._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.LinearCompositionProx._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the cost function associated to the composed function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The cost of the associated composed function</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prox_op</span><span class="o">.</span><span class="n">cost</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">linear_op</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ProximityCombo"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.ProximityCombo">[docs]</a><span class="k">class</span> <span class="nc">ProximityCombo</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Proximity Combo</span>

<span class="sd">    This class defines a combined proximity operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    operators : list</span>
<span class="sd">        List of proximity operator class instances</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from modopt.opt.proximity import ProximityCombo, ProximityParent</span>
<span class="sd">    &gt;&gt;&gt; a = ProximityParent(lambda x: x ** 2, lambda x: x ** 3)</span>
<span class="sd">    &gt;&gt;&gt; b = ProximityParent(lambda x: x ** 4, lambda x: x ** 5)</span>
<span class="sd">    &gt;&gt;&gt; c = ProximityCombo([a, b])</span>
<span class="sd">    &gt;&gt;&gt; c.op([2, 2])</span>
<span class="sd">    array([4, 16], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; c.cost([2, 2])</span>
<span class="sd">    40</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operators</span><span class="p">):</span>

        <span class="n">operators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_operators</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operators</span> <span class="o">=</span> <span class="n">operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

<div class="viewcode-block" id="ProximityCombo._check_operators"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.ProximityCombo._check_operators">[docs]</a>    <span class="k">def</span> <span class="nf">_check_operators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operators</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check operators</span>

<span class="sd">        This method cheks that the input operators and weights are correctly</span>
<span class="sd">        formatted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operators : list, tuple or numpy.ndarray</span>
<span class="sd">            List of linear operator class instances</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Operators</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            For invalid input type</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid input type, operators must be a list, &#39;</span>
                            <span class="s1">&#39;tuple or numpy array.&#39;</span><span class="p">)</span>

        <span class="n">operators</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">operators</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Operator list is empty.&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="n">operators</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="s1">&#39;op&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Operators must contain &quot;op&quot; method.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="s1">&#39;cost&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Operators must contain &quot;cost&quot; method.&#39;</span><span class="p">)</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">check_callable</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="n">check_callable</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">cost</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operators</span></div>

<div class="viewcode-block" id="ProximityCombo._op_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.ProximityCombo._op_method">[docs]</a>    <span class="k">def</span> <span class="nf">_op_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator</span>

<span class="sd">        This method returns the result of applying all of the proximity</span>
<span class="sd">        operators to the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data array</span>
<span class="sd">        extra_factor : float</span>
<span class="sd">            Additional multiplication factor (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Result</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">)):</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">extra_factor</span><span class="o">=</span><span class="n">extra_factor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="ProximityCombo._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.ProximityCombo._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate combined proximity operator components of the cost</span>

<span class="sd">        This method returns the sum of the cost components from each of the</span>
<span class="sd">        proximity operators.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Combinded cost components</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">operator</span><span class="o">.</span><span class="n">cost</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">operator</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span>
                       <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span></div></div>


<div class="viewcode-block" id="OrderedWeightedL1Norm"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.OrderedWeightedL1Norm">[docs]</a><span class="k">class</span> <span class="nc">OrderedWeightedL1Norm</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Ordered Weighted L1 norm proximity operator</span>

<span class="sd">    This class defines the OWL proximity operator described in</span>
<span class="sd">    :cite:`figueiredo2014`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weights : numpy.ndarray</span>
<span class="sd">        Weights values they should be sorted in a non-increasing order</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from modopt.opt.proximity import OrderedWeightedL1Norm</span>
<span class="sd">    &gt;&gt;&gt; A = np.arange(5)*5</span>
<span class="sd">    array([ 0,  5, 10, 15, 20])</span>
<span class="sd">    &gt;&gt;&gt; prox_op = OrderedWeightedL1Norm(np.arange(5))</span>
<span class="sd">    &gt;&gt;&gt; prox_op.weights</span>
<span class="sd">    array([4, 3, 2, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; prox_op.op(A)</span>
<span class="sd">    array([ 0.,  4.,  8., 12., 16.])</span>
<span class="sd">    &gt;&gt;&gt; prox_op.cost(A, verbose=True)</span>
<span class="sd">     - OWL NORM (X): 150</span>
<span class="sd">    150</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">import_sklearn</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;Required version of Scikit-Learn package not&#39;</span>
                              <span class="s1">&#39; found see documentation for details: &#39;</span>
                              <span class="s1">&#39;https://cea-cosmic.github.io/ModOpt/&#39;</span>
                              <span class="s1">&#39;#optional-packages&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Weights must be non increasing&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The weight values must be provided &quot;</span>
                             <span class="s2">&quot;in descending order&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

<div class="viewcode-block" id="OrderedWeightedL1Norm._op_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.OrderedWeightedL1Norm._op_method">[docs]</a>    <span class="k">def</span> <span class="nf">_op_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator</span>

<span class="sd">        This method returns the input data after the a clustering and a</span>
<span class="sd">        thresholding. Implements (Eq 24) in :cite:`figueiredo2014`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data array</span>
<span class="sd">        extra_factor : float</span>
<span class="sd">            Additional multiplication factor (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Thresholded data</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Update threshold with extra factor.</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="n">extra_factor</span>

        <span class="c1"># Squeezing the data</span>
        <span class="n">data_squeezed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c1"># Sorting (non increasing order) input vector&#39;s absolute values</span>
        <span class="n">data_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_squeezed</span><span class="p">)</span>
        <span class="n">data_abs_sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data_abs</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">data_abs</span> <span class="o">=</span> <span class="n">data_abs</span><span class="p">[</span><span class="n">data_abs_sort_idx</span><span class="p">]</span>

        <span class="c1"># Projection onto the monotone non-negative cone using</span>
        <span class="c1"># isotonic_regression</span>

        <span class="n">data_abs</span> <span class="o">=</span> <span class="n">isotonic_regression</span><span class="p">(</span><span class="n">data_abs</span> <span class="o">-</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">y_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                       <span class="n">increasing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Unsorting the data</span>
        <span class="n">data_abs_unsorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">data_abs</span><span class="p">)</span>
        <span class="n">data_abs_unsorted</span><span class="p">[</span><span class="n">data_abs_sort_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_abs</span>

        <span class="c1"># Putting the sign back</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">sign_data</span> <span class="o">=</span> <span class="n">data_squeezed</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_squeezed</span><span class="p">)</span>

        <span class="c1"># Removing NAN caused by the sign</span>
        <span class="n">sign_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sign_data</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">sign_data</span> <span class="o">*</span> <span class="n">data_abs_unsorted</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="OrderedWeightedL1Norm._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.OrderedWeightedL1Norm._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate OWL component of the cost</span>

<span class="sd">        This method returns the ordered weighted l1 norm of the data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            OWL cost component</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cost_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">if</span> <span class="s1">&#39;verbose&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; - OWL NORM (X):&#39;</span><span class="p">,</span> <span class="n">cost_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cost_val</span></div></div>


<div class="viewcode-block" id="Ridge"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.Ridge">[docs]</a><span class="k">class</span> <span class="nc">Ridge</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;L2-norm Proximity Operator (`i.e.` Shrinkage)</span>

<span class="sd">    This class defines the L2-norm proximity operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    linear : class</span>
<span class="sd">        Linear operator class</span>
<span class="sd">    weights : numpy.ndarray</span>
<span class="sd">        Input array of weights</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Implements the following equation:</span>

<span class="sd">    .. math::</span>
<span class="sd">        prox(y) = \underset{x \in \mathbb{C}^N}{argmin} 0.5 \|x-y\||_2^2 +</span>
<span class="sd">        \alpha\|x\|_2^2</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">thresh_type</span><span class="o">=</span><span class="s1">&#39;soft&#39;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span> <span class="o">=</span> <span class="n">linear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

<div class="viewcode-block" id="Ridge._op_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.Ridge._op_method">[docs]</a>    <span class="k">def</span> <span class="nf">_op_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator Method</span>

<span class="sd">        This method returns the input data shrinked by the weights</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data array</span>
<span class="sd">        extra_factor : float</span>
<span class="sd">            Additional multiplication factor (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Thresholded data</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="n">extra_factor</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ridge._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.Ridge._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate Ridge component of the cost</span>

<span class="sd">        This method returns the l2 norm error of the weighted wavelet</span>
<span class="sd">        coefficients.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Sparsity cost component</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cost_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="s1">&#39;verbose&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; - L2 NORM (X):&#39;</span><span class="p">,</span> <span class="n">cost_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cost_val</span></div></div>


<div class="viewcode-block" id="ElasticNet"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.ElasticNet">[docs]</a><span class="k">class</span> <span class="nc">ElasticNet</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Elastic Net</span>

<span class="sd">    This class defines the Elastic net proximity operator, which is  a</span>
<span class="sd">    linear combination between L2 and L1 norm proximity operators,</span>
<span class="sd">    described in :cite:`zou2005`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha : numpy.ndarray</span>
<span class="sd">        Weights for the L2 norm</span>
<span class="sd">    beta : numpy.ndarray</span>
<span class="sd">        Weights for the L1 norm</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Implements the following equation:</span>

<span class="sd">    .. math::</span>
<span class="sd">        prox(y) = \underset{x \in \mathbb{C}^N}{argmin} 0.5 \|x-y\||_2^2 +</span>
<span class="sd">        \alpha\|x\|_2^2 + beta*||x||_1</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span> <span class="o">=</span> <span class="n">linear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

<div class="viewcode-block" id="ElasticNet._op_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.ElasticNet._op_method">[docs]</a>    <span class="k">def</span> <span class="nf">_op_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator</span>

<span class="sd">        This method returns the input data shrinked by the weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data array</span>
<span class="sd">        extra_factor : float</span>
<span class="sd">            Additional multiplication factor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Thresholded data</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">soft_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">extra_factor</span>
        <span class="n">normalization</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">extra_factor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">thresh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">soft_threshold</span><span class="p">,</span> <span class="s1">&#39;soft&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">normalization</span></div>

<div class="viewcode-block" id="ElasticNet._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.ElasticNet._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate Ridge component of the cost</span>

<span class="sd">        This method returns the l2 norm error of the weighted wavelet</span>
<span class="sd">        coefficients.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Sparsity cost component</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cost_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

        <span class="k">if</span> <span class="s1">&#39;verbose&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; - ELASTIC NET (X):&#39;</span><span class="p">,</span> <span class="n">cost_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cost_val</span></div></div>


<div class="viewcode-block" id="KSupportNorm"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.KSupportNorm">[docs]</a><span class="k">class</span> <span class="nc">KSupportNorm</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;K-support Norm Proximity Operator</span>

<span class="sd">    This class defines the squarred K-support norm proximity operator</span>
<span class="sd">    described in :cite:`mcdonald2014`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    thresh : float</span>
<span class="sd">        Threshold value</span>
<span class="sd">    k_value : int</span>
<span class="sd">        Hyper-parameter of the k-support norm, equivalent to the cardinality</span>
<span class="sd">        value for the overlapping group lasso. k should included in</span>
<span class="sd">        {1, ..., dim(input_vector)}</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The k-support norm can be seen as an extension to the group-LASSO with</span>
<span class="sd">    overlaps with groups of cardianlity at most equal to k.</span>
<span class="sd">    When k = 1 the norm is equivalent to the L1-norm.</span>
<span class="sd">    When k = dimension of the input vector than the norm is equivalent to the</span>
<span class="sd">    L2-norm.</span>
<span class="sd">    The dual of this norm correspond to the sum of the k biggest input entries.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from modopt.opt.proximity import KSupportNorm</span>
<span class="sd">    &gt;&gt;&gt; A = np.arange(5)*5</span>
<span class="sd">    array([ 0,  5, 10, 15, 20])</span>
<span class="sd">    &gt;&gt;&gt; prox_op = KSupportNorm(beta=3, k_value=1)</span>
<span class="sd">    &gt;&gt;&gt; prox_op.op(A)</span>
<span class="sd">    array([ 0.,  0.,  0., 0., 5.])</span>
<span class="sd">    &gt;&gt;&gt; prox_op.cost(A, verbose=True)</span>
<span class="sd">     - OWL NORM (X): 7500.0</span>
<span class="sd">    7500.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">k_value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_value</span> <span class="o">=</span> <span class="n">k_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">k_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;k value</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span>

    <span class="nd">@k_value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">k_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The k parameter should be greater or &quot;</span>
                             <span class="s2">&quot;equal than 1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">=</span> <span class="n">k</span>

<div class="viewcode-block" id="KSupportNorm._compute_theta"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.KSupportNorm._compute_theta">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute theta</span>

<span class="sd">        This method computes theta from Corollary 16:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{align*}</span>
<span class="sd">            \theta_i &amp;=</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            1, &amp; \text{if} \, \alpha \vert w_i \vert - 2 \lambda &gt; 1\\</span>
<span class="sd">            \alpha \vert w_i \vert - 2 \lambda, &amp; \text{if} \</span>
<span class="sd">            1 \geq \alpha \vert w_i \vert -2 \lambda \geq 0 \\</span>
<span class="sd">            0, &amp; \text{if} \, 0 &gt; \alpha \vert w_i \vert - 2 \lambda</span>
<span class="sd">            \end{cases}</span>
<span class="sd">            \end{align*}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_data: numpy.ndarray</span>
<span class="sd">            Input data</span>
<span class="sd">        alpha: float</span>
<span class="sd">            Parameter choosen such that sum(theta_i) = k</span>
<span class="sd">        extra_factor: float</span>
<span class="sd">            Potential extra factor comming from the optimization process</span>
<span class="sd">            (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        theta: numpy.ndarray</span>
<span class="sd">            Same size as w and each component is equal to theta_i</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alpha_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">input_data</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">alpha_input</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha_input</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">extra_factor</span><span class="p">)</span> <span class="o">*</span> \
                <span class="p">(((</span><span class="n">alpha_input</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">extra_factor</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
                 <span class="p">((</span><span class="n">alpha_input</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">extra_factor</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">+=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha_input</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">extra_factor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">theta</span></div>

<div class="viewcode-block" id="KSupportNorm._interpolate"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.KSupportNorm._interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">_interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha_0</span><span class="p">,</span> <span class="n">alpha_1</span><span class="p">,</span> <span class="n">sum_0</span><span class="p">,</span> <span class="n">sum_1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Linear interpolation of alpha</span>

<span class="sd">        This method estimats alpha* such that sum(theta(alpha*))=k via a linear</span>
<span class="sd">        interpolation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        alpha_0: float</span>
<span class="sd">            A value for wich sum(theta(alpha_0)) &lt;= k</span>
<span class="sd">        alpha_1: float</span>
<span class="sd">            A value for which sum(theta(alpha_1)) &lt;= k</span>
<span class="sd">        sum_0: float</span>
<span class="sd">            Value of sum(theta(alpha_0))</span>
<span class="sd">        sum_1:</span>
<span class="sd">            Value of sum(theta(alpha_0))</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            An interpolation for which sum(theta(alpha_star)) = k</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sum_0</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">alpha_0</span>
        <span class="k">elif</span> <span class="n">sum_1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">alpha_1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_1</span> <span class="o">-</span> <span class="n">sum_0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">alpha_1</span> <span class="o">-</span> <span class="n">alpha_0</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">sum_0</span> <span class="o">-</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">alpha_0</span>
            <span class="n">alpha_star</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">slope</span>
            <span class="k">return</span> <span class="n">alpha_star</span></div>

<div class="viewcode-block" id="KSupportNorm._binary_search"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.KSupportNorm._binary_search">[docs]</a>    <span class="k">def</span> <span class="nf">_binary_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Binary search method</span>

<span class="sd">        This method finds the coordinate of alpha (i) such that</span>
<span class="sd">        sum(theta(alpha[i])) =&lt; k and sum(theta(alpha[i+1])) &gt;= k via binary</span>
<span class="sd">        search method</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: numpy.ndarray</span>
<span class="sd">            absolute value of the input data</span>
<span class="sd">        alpha: numpy.ndarray</span>
<span class="sd">            Array same size as the input data</span>
<span class="sd">        extra_factor: float</span>
<span class="sd">            Potential extra factor comming from the optimization process</span>
<span class="sd">            (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            The index where: sum(theta(alpha[index])) &lt;= k and</span>
<span class="sd">            sum(theta(alpha[index+1])) &gt;= k, The alpha value for which</span>
<span class="sd">            sum(theta(alpha[index])) &lt;= k,  The alpha value for which</span>
<span class="sd">            sum(theta(alpha[index+1])) &gt;= k, Value of sum(theta(alpha[index])),</span>
<span class="sd">            Value of sum(theta(alpha[index + 1]))</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">first_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">data_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">last_idx</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">prev_midpoint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Avoid infinite looops</span>

        <span class="c1"># Checking particular to be sure that the solution is in the array</span>
        <span class="n">sum_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_theta</span><span class="p">(</span><span class="n">data_abs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extra_factor</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">sum_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_theta</span><span class="p">(</span><span class="n">data_abs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">extra_factor</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sum_1</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">:</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">sum_0</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">midpoint</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">first_idx</span> <span class="o">&lt;=</span> <span class="n">last_idx</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="n">midpoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_idx</span> <span class="o">+</span> <span class="n">last_idx</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">prev_midpoint</span> <span class="o">==</span> <span class="n">midpoint</span><span class="p">:</span>

                <span class="c1"># Particular case</span>
                <span class="n">sum_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_theta</span><span class="p">(</span><span class="n">data_abs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">first_idx</span><span class="p">],</span>
                                            <span class="n">extra_factor</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">sum_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_theta</span><span class="p">(</span><span class="n">data_abs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">last_idx</span><span class="p">],</span>
                                            <span class="n">extra_factor</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sum_0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-4</span><span class="p">):</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">midpoint</span> <span class="o">=</span> <span class="n">first_idx</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sum_1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-4</span><span class="p">):</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">midpoint</span> <span class="o">=</span> <span class="n">last_idx</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="c1"># -1 because output is index such that</span>
                    <span class="c1"># sum(theta(alpha[index])) &lt;= k</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">first_idx</span> <span class="o">-</span> <span class="n">last_idx</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">first_idx</span> <span class="o">-</span> <span class="n">last_idx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">sum_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_theta</span><span class="p">(</span><span class="n">data_abs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">first_idx</span><span class="p">],</span>
                                                <span class="n">extra_factor</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">sum_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_theta</span><span class="p">(</span><span class="n">data_abs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">last_idx</span><span class="p">],</span>
                                                <span class="n">extra_factor</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">sum_0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sum_1</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">):</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">sum_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_theta</span><span class="p">(</span><span class="n">data_abs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">midpoint</span><span class="p">],</span>
                                        <span class="n">extra_factor</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">sum_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_theta</span><span class="p">(</span><span class="n">data_abs</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">midpoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                        <span class="n">extra_factor</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">sum_0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sum_1</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">):</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">elif</span> <span class="n">sum_1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">:</span>
                <span class="n">first_idx</span> <span class="o">=</span> <span class="n">midpoint</span>

            <span class="k">elif</span> <span class="n">sum_0</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">:</span>
                <span class="n">last_idx</span> <span class="o">=</span> <span class="n">midpoint</span>

            <span class="n">prev_midpoint</span> <span class="o">=</span> <span class="n">midpoint</span>

        <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">midpoint</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">midpoint</span><span class="p">],</span> <span class="n">alpha</span><span class="p">[</span><span class="n">midpoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sum_0</span><span class="p">,</span>\
                   <span class="n">sum_1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find the coordinate of alpha (i) such &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;that sum(theta(alpha[i])) =&lt; k and &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;sum(theta(alpha[i+1])) &gt;= k &quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="KSupportNorm._find_alpha"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.KSupportNorm._find_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">_find_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find alpha value to compute theta</span>

<span class="sd">        This method aim at finding alpha such that sum(theta(alpha)) = k.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_data: numpy.ndarray</span>
<span class="sd">            Input data</span>
<span class="sd">        extra_factor: float</span>
<span class="sd">            Potential extra factor for the weights (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            An interpolation of alpha such that sum(theta(alpha)) = k</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_size</span> <span class="o">=</span> <span class="n">input_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Computes the alpha^i points line 1 in Algorithm 1.</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data_size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">data_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">[:</span><span class="n">data_size</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">extra_factor</span><span class="p">)</span> <span class="o">/</span> \
                            <span class="p">(</span><span class="n">data_abs</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span><span class="p">)</span>
        <span class="n">alpha</span><span class="p">[</span><span class="n">data_size</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">extra_factor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> \
                            <span class="p">(</span><span class="n">data_abs</span> <span class="o">+</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>

        <span class="c1"># Identify points alpha^i and alpha^{i+1} line 2. Algorithm 1</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">alpha_0</span><span class="p">,</span> <span class="n">alpha_1</span><span class="p">,</span> <span class="n">sum_0</span><span class="p">,</span> <span class="n">sum_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_search</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span>
                                                                <span class="n">alpha</span><span class="p">,</span>
                                                                <span class="n">extra_factor</span><span class="p">)</span>

        <span class="c1"># Interpolate alpha^\star such that its sum is equal to k</span>
        <span class="n">alpha_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate</span><span class="p">(</span><span class="n">alpha_0</span><span class="p">,</span> <span class="n">alpha_1</span><span class="p">,</span> <span class="n">sum_0</span><span class="p">,</span> <span class="n">sum_1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">alpha_star</span></div>

<div class="viewcode-block" id="KSupportNorm._op_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.KSupportNorm._op_method">[docs]</a>    <span class="k">def</span> <span class="nf">_op_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator</span>

<span class="sd">        This method returns the proximity operator of the squared k-support</span>
<span class="sd">        norm. Implements (Alg. 1) in :cite:`mcdonald2014`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data array</span>
<span class="sd">        extra_factor : float</span>
<span class="sd">            Additional multiplication factor (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Proximal map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">k_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">data_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">&gt;</span> <span class="n">k_max</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;K value of the K-support norm is greater than the input&quot;</span> <span class="o">+</span>
                 <span class="s2">&quot; dimension, its value will be set to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">k_max</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">=</span> <span class="n">k_max</span>

        <span class="c1"># Computes line 1., 2. and 3. in Algorithm 1</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_alpha</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">extra_factor</span><span class="p">)</span>

        <span class="c1"># Computes line 4. in Algorithm 1</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_theta</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="c1"># Computes line 5. in Algorithm 1.</span>
        <span class="n">rslt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)</span> <span class="o">/</span>
                             <span class="p">(</span><span class="n">theta</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">extra_factor</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rslt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data_shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="KSupportNorm._find_q"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.KSupportNorm._find_q">[docs]</a>    <span class="k">def</span> <span class="nf">_find_q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sorted_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Find q index value</span>

<span class="sd">        This method finds the value of q such that:</span>

<span class="sd">        sorted_data[q] &gt;= sum(sorted_data[q+1:]) / (k - q)&gt;= sorted_data[q+1]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sorted_data : numpy.ndarray</span>
<span class="sd">            Absolute value of the input data sorted in a non-decreasing order</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            index such that sorted_data[q] &gt;= sum(sorted_data[q+1:]) /</span>
<span class="sd">            (k - q)&gt;= sorted_data[q+1]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">first_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">last_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_idx</span> <span class="o">+</span> <span class="n">last_idx</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Particular case</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sorted_data</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">sorted_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">sorted_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="n">sorted_data</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="p">(</span><span class="ow">not</span> <span class="n">found</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cnt</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="ow">and</span>
               <span class="p">(</span><span class="n">first_idx</span> <span class="o">&lt;=</span> <span class="n">last_idx</span><span class="p">)</span> <span class="ow">and</span> <span class="n">last_idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span><span class="p">):</span>

            <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_idx</span> <span class="o">+</span> <span class="n">last_idx</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">l1_part</span> <span class="o">=</span> <span class="n">sorted_data</span><span class="p">[</span><span class="n">q</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sorted_data</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">l1_part</span> <span class="ow">and</span> <span class="n">l1_part</span> <span class="o">&gt;=</span> <span class="n">sorted_data</span><span class="p">[</span><span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sorted_data</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l1_part</span><span class="p">:</span>
                    <span class="n">last_idx</span> <span class="o">=</span> <span class="n">q</span>
                <span class="k">if</span> <span class="n">l1_part</span> <span class="o">&lt;=</span> <span class="n">sorted_data</span><span class="p">[</span><span class="n">q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">first_idx</span> <span class="o">=</span> <span class="n">q</span>
        <span class="k">return</span> <span class="n">q</span></div>

<div class="viewcode-block" id="KSupportNorm._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.KSupportNorm._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate OWL component of the cost</span>

<span class="sd">        This method returns the ordered weighted l1 norm of the data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            OWL cost component</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data_abs</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">data_abs</span> <span class="o">=</span> <span class="n">data_abs</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>  <span class="c1"># Sorted absolute value of the data</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_q</span><span class="p">(</span><span class="n">data_abs</span><span class="p">)</span>
        <span class="n">cost_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data_abs</span><span class="p">[:</span><span class="n">q</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data_abs</span><span class="p">[</span><span class="n">q</span><span class="p">:])</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k_value</span> <span class="o">-</span> <span class="n">q</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>

        <span class="k">if</span> <span class="s1">&#39;verbose&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;verbose&#39;</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; - K-SUPPORT NORM (X):&#39;</span><span class="p">,</span> <span class="n">cost_val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cost_val</span></div></div>


<div class="viewcode-block" id="GroupLASSO"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.GroupLASSO">[docs]</a><span class="k">class</span> <span class="nc">GroupLASSO</span><span class="p">(</span><span class="n">ProximityParent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Group LASSO norm proximity</span>

<span class="sd">    This class implements the proximity operator of the group-lasso</span>
<span class="sd">    regularization as defined in :cite:`yuan2006`, with groups dimension</span>
<span class="sd">    being the first dimension.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weights : numpy.ndarray</span>
<span class="sd">        Input array of weights</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from modopt.opt.proximity import GroupLASSO</span>
<span class="sd">    &gt;&gt;&gt; A = np.arange(15).reshape(3,5)</span>
<span class="sd">    array([[ 0,  1,  2,  3,  4],</span>
<span class="sd">           [ 5,  6,  7,  8,  9],</span>
<span class="sd">           [10, 11, 12, 13, 14]])</span>
<span class="sd">    &gt;&gt;&gt; prox_op = GroupLASSO(weights=3)</span>
<span class="sd">    &gt;&gt;&gt; prox_op.op(A)</span>
<span class="sd">    array([[ 0.        ,  0.76133281,  1.5725177 ,  2.42145809,  3.29895251],</span>
<span class="sd">           [ 3.65835921,  4.56799689,  5.50381195,  6.45722157,  7.42264316],</span>
<span class="sd">           [ 7.31671843,  8.37466096,  9.4351062 , 10.49298505, 11.5463338 ]])</span>
<span class="sd">    &gt;&gt;&gt; prox_op.cost(A, verbose=True)</span>
<span class="sd">         211.37821733946427</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProximityParent : parent class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cost_method</span>

<div class="viewcode-block" id="GroupLASSO._op_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.GroupLASSO._op_method">[docs]</a>    <span class="k">def</span> <span class="nf">_op_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">extra_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Operator</span>

<span class="sd">        This method returns the input data thresholded by the weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data array</span>
<span class="sd">        extra_factor : float</span>
<span class="sd">            Additional multiplication factor (default is ``1.0``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            With proximal of GroupLASSO regularization</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">norm_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="n">extra_factor</span> <span class="o">/</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">norm_2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">))</span></div>

<div class="viewcode-block" id="GroupLASSO._cost_method"><a class="viewcode-back" href="../../../modopt.opt.proximity.html#modopt.opt.proximity.GroupLASSO._cost_method">[docs]</a>    <span class="k">def</span> <span class="nf">_cost_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cost function</span>

<span class="sd">        This method calculate the cost function of the proximable part.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: numpy.ndarray</span>
<span class="sd">            Input array of the sparse code</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            The cost of GroupLASSO regularizer</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Samuel Farrens

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>